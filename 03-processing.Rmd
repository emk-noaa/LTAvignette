# Data processing {#processing}

```{r, echo=FALSE, eval=TRUE, collapse=TRUE, include=FALSE}
library(dplyr)
library(magrittr)
library(LTabundR)
library(swfscDAS)

data(settings)
```


## Bring in cruise data {-} 

Specify the path to your `.DAS` data file(s):  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
das_file <- 'data/surveys/HICEASwinter2020.das'
```

Read in and process this `.DAS` file using the functions in Sam's `swfscDAS` package. To do so quickly, we built a wrapper function that makes this quick and easy: 

```{r, echo=TRUE, eval=TRUE, collapse=FALSE}
das <- load_das(das_file, 
                perform_checks = TRUE,
                print_glimpse = TRUE)
```

## Format `DAS` data {-}  

Finalize formatting: remove rows with invalid locations and calculate the distance, in km, between each row of data.  Other refinements can be added to this function later on.  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
das <- format_das(das, settings)
```

```{r, echo=TRUE, eval=TRUE, collapse=TRUE, fig.width=8, fig.height=4}
par(mfrow=c(1,2))
hist(das$km_int, xlab='KM between each DAS row', 
     main=NULL, breaks=seq(0,max(das$km_int),length=100))
plot(das$km_cum, ylab='Cumulative KM surveyed', main=NULL, type='l')
```

## Process strata {-}  

Run the following function to add strata and study-area information to each sub-segment of effort:  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz <- process_strata(das, settings)
```

This function loops through each stratum `data.frame` you have provided it in `settings$strata`, formats the stratum, and asks whether each DAS row occurs within it. For each stratum, a column named `stratum_<StratumName>` is added to the `das` object; each row in this column is `TRUE` (included) or `FALSE`.

A similar procedure is run if a dataframe is provided in `settings$study_area`. A column named `study_area` is added to `das` containing a boolean (`TRUE` if the sub-segment or sighting occurs within the study area). 

The function then loops through each species cohort and uses that cohort's settings to determine a single stratum assignment for each row of `DAS` data in the event of overlapping strata. The key cohort setting referenced here is `stratum_overlap_handling`.  

### The `cruz` object {-}

The function `process_strata()` returns a list, which we have saved in an object named `cruz`, with several slots:  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz %>% names
```

The slots `strata` and `study_area` provide the area, in square km, of each polygon being used:  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$strata
```

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$study_area
```

The slot `cohorts` is itself a list with one slot for each cohort. The slots are named using the `id` cohort setting.  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts %>% names
```

Each cohort slot has a copy of the `DAS` data with a stratum assignment tailored to its cohort-specific settings. For instance, the `default` cohort, whose `stratum_overlap_handling` is set to `"smallest"`, assigns the smallest stratum in the event of overlapping or nested strata:

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default$stratum %>% table(useNA='ifany')
```

The `fkw_insular` cohort, whose `stratum_overlap_handling` is set to `"each"` (i.e., effort is allowed to belong to multiple segments, if they overlap, and all analyses will be conducted for each stratum separately), has stratum assignments that look like this;  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$fkw_insular$stratum %>% table(useNA='ifany')
```

When a row of `DAS` effort occurs in two overlapping strata, the stratum assignment for that row is a concatentation of the names of the strata it falls within, with names separated by "`&`".   

This list, with these five primary slots, will be referred to as a `cruz` object. The remainder of the data processing work flow is focused upon refining the effort and sighting data for each slot in `cohorts`. The other slots are no longer modified.  


## Segmentize the data {-} 

To allocate survey data into discrete 'effort segments', which are used in variance estimation in subsequent steps, run the function `segmentize()`. This process is controlled by both survey-wide and cohort-specific [settings]{#settings}, which are now carried in a slot within the `cruz` object.  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz <- segmentize(cruz, verbose=TRUE)
```

This function does not change the high-level structure of the `cruz` object ...

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz %>% names
```

... or the cohort names in the `cohorts` slot ...  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts %>% names
```

But it *does* change the structure of data within each cohort.  Each cohort will now have a slot named `density` ...  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default %>% names
```

And, if your settings specify that settings for density estimation differ from detection function estimation, a cohort will have a second slot named `distance`.  This is the case for the second cohort in our example analysis: `fkw_insular`.  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$fkw_insular %>% names
```

Though their data segmentization will differ, the `density` and `distance` slots have identical structures:  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$fkw_insular$density %>% names

cruz$cohorts$fkw_insular$distance %>% names
```

The `segments` slot contains summary data for each effort segment, including start/mid/end coordinates, average conditions, and segment distance:  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default$density$segments %>% glimpse
```

```{r, echo=TRUE, eval=TRUE, collapse=TRUE, fig.width=7, fig.height=4}
# Number of segments
cruz$cohorts$default$density$segments %>% nrow

# Segment length distribution
hist(cruz$cohorts$default$density$segments$dist,
     breaks = seq(0,60,by=1),
     xlab='Segment lengths (km)',
     main=paste0('Target km: ',settings$survey$segment_target_km))
```

The `effort` slot is itself a list in which each slot holds the `DAS` for a single segment.   

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default$density$effort %>% length
```

And the `das` slot holds the original `data.frame` of `DAS` data, modified slightly: the column `OnEffort` has been modified according to Beaufort range conditions, and the column `seg_id` indicates which segment the event occurs within  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default$density$das %>% names
```

The `segmentize()` function and its associated settings were designed to give researchers full control over how data are segmented, be it for design-based density analysis (which tend to use long segments of 100 km or more and allow for non-contiguous effort to be included in the same segment) or for habitat modeling (which tend to use short segments of 5 - 10 km and disallow non-contiguous effort to be pooled into the same segment). To demonstrate that versatility, checkout the [appendix on segmentizing](#segmentizing).  


## Process sightings {-}  

To process sightings for each cohort of species, use the function `process_sightings()`. This function has three basic steps: for each cohort, the function (1) prepares a sightings table using the function `das_sight()` from `swfscDAS`; (2) filters those sightings to species codes specified for the cohort in your `settings` input; and (3) evaluates each of those sightings, asking if each should be included in the analysis according to your `settings`.  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE, max.height='100px'}
cruz <- process_sightings(cruz)
```

The function produces a formatted dataset and adds it to a new `sightings` slot. It does this for each analysis (`density` and, if specified, `distance`) in each cohort.  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default$density %>% names
cruz$cohorts$fkw_insular$density %>% names
cruz$cohorts$fkw_insular$distance %>% names
```

Note that the `sightings` table has a column named `included` (`TRUE` = yes, use it in the analysis). Any sightings that do not meet the inclusion criteria as specified in your settings will be `included = FALSE`, but they won't be removed from the data.   

Since the sightings in each cohort are processed slightly differently, and since each cohort is species-group specific, you should expect different numbers of included/excluded sightings in each cohort-analysis dataset:  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default$density$sightings$included %>% table
cruz$cohorts$fkw_insular$density$sightings$included %>% table
cruz$cohorts$fkw_insular$distance$sightings$included %>% table
```

When this function's `verbose` argument is `TRUE` (the default), a message is printed each time a sighting does not meet the inclusion criteria (see above).

### Sightings data structure {-}  

The `sightings` table has many other variables: 

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default$density$sightings %>% names
```

Here is a glimpse of the data: 

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$fkw_insular$distance$sightings %>% glimpse
```

Note that the `process_sightings()` function draws upon `cruz$settings` for inclusion criteria, but some of those settings can be overridden with the function's manual inputs if you want to explore your options. 


### School size estimates {.unnumbered #ss_calibration} 

In the settings we are using in this tutorial, school size estimates are adjusted using the calibration models from [Barlow, Gerrodette, and Perryman (1998)](https://scholar.google.com/scholar?hl=en&as_sdt=0%2C43&q=barlow+1998+group+size+caliration&btnG=) (their analysis is refined slightly and further explained in [Gerrodette, Perryman and Barlow, 2002](https://scholar.google.com/scholar?hl=en&as_sdt=0%2C43&q=barlow+1998+group+size+caliration&btnG=)). These calibration corrections are observer-specific. Some observers tend to underestimate school size and their estimates are adjusted up; others tend to overestimate and their estimates are adjusted down. Some observers do not have calibration coefficients, and for them a generic adjustment (upwards, by dividing estimates by 0.8625) is used. Each observer's estimate is calibrated, then all observer estimates are averaged. To do that averaging, our `settings` specify that we shall use a geometric weighted mean, instead of an arithmetic mean, that weights school size estimates from multiple observers according to the variance of their calibration coefficients.   

Here are our current best estimates of school size:  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz$cohorts$default$density$sightings$best %>% head(20)
```

Let's compare those estimates to unadjusted ones, in which calibration (and therefore weighted geometric mean) is turned off:  

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz_demo <- process_sightings(cruz, 
                               calibrate = FALSE,
                               verbose = FALSE)
cruz_demo$cohorts$default$density$sightings$best %>% head(20)
```

Since calibration is only used for schools above a certain size, the difference between calibration and non-calibrated estimates becomes clearer in larger groups.  

You can also carry out calibration corrections without using a geometric weighted mean (the arithmetic mean will be used instead): 

```{r, echo=TRUE, eval=TRUE, collapse=TRUE}
cruz_demo <- process_sightings(cruz, 
                               calibrate = TRUE,
                               geometric_mean = FALSE,
                               verbose = FALSE)

cruz_demo$cohorts$default$density$sightings$best %>% head(20)
```

Note that school size calibration is only carried out if `settings$group_size_calibration` is not `NULL`.  However, even when calibration coefficients *are* provided, calibration is only carried out for raw estimates above a minimum threshold, since observers are unlikely to mis-estimate the school size of a lone whale or pair. For observers who have calibration coefficients in the `settings$group_size_coefficients` table, that minimum is specified for each observer individually. For observers not in that table, calibration will only be applied to raw school size estimates of 4 or above.   

```{r, echo=FALSE, eval=TRUE, collapse=TRUE, include=FALSE}
save(cruz,file='data/cruz_proc.RData')
```

